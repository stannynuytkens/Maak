using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection.Metadata;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace Maak.CodeFixes.ModelBuilder
{
    [ExcludeFromCodeCoverage]
    public class ModelBuilderGenerator
    {
        public TypeDefinition MapTypeDeclarationSyntax(INamedTypeSymbol symbol)
        {
            var definition = new TypeDefinition
            {
                Name = symbol?.Name,
                Assembly = symbol?.ContainingAssembly?.Name,
                Namespace = symbol?.ContainingNamespace?.ToString(),
                Properties = (symbol?.GetMembers() ?? new ImmutableArray<ISymbol>())
                    .OfType<IPropertySymbol>()
                    .Where(prop => !prop.IsReadOnly)
                    .ToList()
            };
            return definition;
        }

        public string GetSourceFile(TypeDefinition typeDefinition, List<TypeDefinition> typeDefinitions)
        {
            var builderName = $"{typeDefinition.Name}Builder";
            var builderNamespace = $"{typeDefinition.Namespace}.Builder";
            var propertiesAndUsings = BuilderDefaults(typeDefinitions, typeDefinition);
            var formattedUsings = propertiesAndUsings.Usings.Distinct().Select(u => $"using {u};");
            var usings = string.Join(Environment.NewLine, formattedUsings);

            var source = $@"
                    //------------------------------------------------------------------------------
                    // <auto-generated>
                    //     This code was generated using a C# 9.0 source code generation feature! (requires .NET SDK 5.x)
                    //     Runtime Version: ${typeof(string).Assembly.ImageRuntimeVersion}
                    // </auto-generated>
                    //------------------------------------------------------------------------------

                    using System;
                    using System.Collections.Generic;
                    
                    {usings}

                    namespace {builderNamespace}
                    {{
                        public class {builderName}: GenericModelBuilder<{typeDefinition.Name}>
                        {{
                            public {builderName}()
                            {{
                                SetDefaultRules((faker, model) =>
                                {{
                                    {propertiesAndUsings.Properties}
                                }});
                            }}
                        }}
                    }}";

            return SyntaxFactory.ParseCompilationUnit(source).NormalizeWhitespace().ToString();
        }

        private (string Properties, List<string> Usings) BuilderDefaults(List<TypeDefinition> typeDefinitions, TypeDefinition typeDefinition)
        {
            var stringBuilder = new StringBuilder();
            var usings = new List<string> { typeDefinition.Namespace };
            foreach (var property in typeDefinition.Properties)
            {
                var typeDefinitionForProperty = typeDefinitions.SingleOrDefault(e => e.ToString() == property.Type.ToString());
                if (typeDefinitionForProperty != null)
                {
                    stringBuilder.AppendLine($"model.{property.Name} = new {property.Type.Name}Builder().Build();");
                    usings.Add($"{typeDefinitionForProperty.Namespace}.Builder");
                }
                else if (property.Type.Name.Equals(nameof(String), StringComparison.OrdinalIgnoreCase))
                {
                    stringBuilder.AppendLine($"model.{property.Name} = nameof({typeDefinition.Name}.{property.Name});");
                }
                else if (property.Type.IsValueType)
                {
                    var type = property.NullableAnnotation == NullableAnnotation.Annotated ? ((INamedTypeSymbol)property.Type).TypeArguments.First() : property.Type;
                    GenerateValueTypeDefaults(type, stringBuilder, property);
                }
                else if (property.Type.AllInterfaces.Any(x => x.Name == nameof(System.Collections.IEnumerable)))
                {
                    // what about IEnumerable<TEnum> or other implementations than List?
                    var collectionFullName = property.Type.ToString().Replace(nameof(System.Collections.IEnumerable), "List");
                    stringBuilder.AppendLine($"model.{property.Name} = new {collectionFullName}" + "{};");
                }
                else
                {
                    //Diagnostic.ReportWarning($"Not mapped {property.Type.Name}");
                }
            }

            return (stringBuilder.ToString(), usings);
        }



        private static void GenerateValueTypeDefaults(ITypeSymbol type, StringBuilder stringBuilder, ISymbol property)
        {
            if (type.Name.Equals(nameof(DateTime), StringComparison.OrdinalIgnoreCase))
            {
                stringBuilder.AppendLine($"model.{property.Name} = faker.Date.Future();");
            }
            else if (type.Name.Equals(nameof(DateTimeOffset), StringComparison.OrdinalIgnoreCase))
            {
                stringBuilder.AppendLine($"model.{property.Name} = new DateTimeOffset(faker.Date.Future());");
            }
            else if (type.BaseType?.Name.Equals(nameof(Enum)) == true)
            {
                stringBuilder.AppendLine($"model.{property.Name} = faker.Random.Enum<{type}>();");
            }
            else
            {
                var typeName = type.ToString().Replace("System.", string.Empty);
                var functionName = typeName.ToPascalCase();
                stringBuilder.AppendLine($"model.{property.Name} = faker.Random.{functionName}();");
            }
        }
    }
}